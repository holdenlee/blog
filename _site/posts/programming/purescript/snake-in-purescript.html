<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->

  <meta name="description" content="Holden Lee's Blog">
  <meta name="author" content="Holden Lee">
    
  <title>Snake in Purescript</title>

  <!-- Bootstrap core CSS -->
  <link href="../../../bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
  <!-- <link href="../../assets/css/ie10-viewport-bug-workaround.css" rel="stylesheet"> -->

  <!-- Custom styles for this template -->
  <link href="../../../css/blog.css" rel="stylesheet">
  <link href="../../../css/default.css" rel="stylesheet">

  <!-- Extension : Footnotes -->
  <link href="../../../footnotes/css/footnotes.css" rel="stylesheet">

  <!-- Extension : InlineDisqussions @ https://github.com/tsi/inlineDisqussions -->
  
  <link href="../../../disqus/css/inlineDisqussions.css" rel="stylesheet">
  

  
  <!-- Extension : Share buttons @ http://www.sharethis.com/get-sharing-tools/# -->
  <script type="text/javascript" src="http://w.sharethis.com/button/buttons.js">  </script>
  <script type="text/javascript">stLight.options({publisher: "307929ab-483f-4a25-8ef0-76ff5bd12e05", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>
  

</head>

<body>

<!-- Navigation bar. navbar-inverse is black, navbar-default is white.-->
<!-- To make a button active (pressed), use <li class="active"> -->
<div id="header">
  <nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../">Holden's Blog</a>
      </div>
      <div id="navbar" class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="../../../">Home</a></li>
          <li><a href="../../../sitemap.html">Sitemap</a></li>
          <li><a href="../../../about.html">About</a></li>
          <li><a href="../../../notes.html">Notes</a></li>
          <li><a href="../../../creations.html">Creations</a></li>
          <li><a href="../../../links.html">Links</a></li>
<!-- TODO: make this part a for loop over main pages -->
        </ul>
      </div><!--/.nav-collapse -->
    </div>
  </nav>
</div>
<!-- Content -->
<!--div id="content">
  <h1>Mental Wilderness</h1>-->



<div class="container">
  <div id="content">
    <div class="page header">
      <h1>Snake in Purescript</h1>
    </div>
    <div class="info">
       <div class="subtitle"><p>How to program a simple game in Purescript</p></div> 
       
        <p>Posted: 2016-11-06 
          , Modified: 2016-11-06 
	</p>
      
       <p>Tags: <a href="../../../tags/purescript.html">purescript</a>, <a href="../../../tags/programming.html">programming</a>, <a href="../../../tags/functional%20programming.html">functional programming</a>, <a href="../../../tags/game.html">game</a></p> 
    </div>
    
  </div>
  <!--/div-->

  <div class="toc"> <ul>
 <li><a href="#introduction">Introduction</a></li>
 <li><a href="#getting-started">Getting started</a></li>
 <li><a href="#imports">Imports</a></li>
 <li><a href="#the-model-update-view-signal-architecture">The Model-Update-View-Signal Architecture</a></li>
 <li><a href="#model">Model</a></li>
 <li><a href="#update">Update</a></li>
 <li><a href="#view">View</a></li>
 <li><a href="#signal">Signal</a></li>
 <li><a href="#adding-randomness">Adding randomness</a><ul>
 <li><a href="#something-that-doesnt-work">Something that doesn’t work</a></li>
 <li><a href="#using-a-generator">Using a generator</a></li>
 </ul></li>
 <li><a href="#building">Building</a></li>
 </ul> </div>

  <div class="blog-main">
    <h2 id="introduction">Introduction</h2>
<ul>
<li>Play the game <a href="https://holdenlee.github.io/purescript-games/html/SnakeS.html">here</a>.</li>
<li>Check out the code on <a href="https://github.com/holdenlee/purescript-games">github</a>.
<ul>
<li>The code for <code>Snake.purs</code> is <a href="https://github.com/holdenlee/purescript-games/blob/master/src/Snake.purs">here</a>.</li>
</ul></li>
</ul>
<p><a href="http://www.purescript.org/">Purescript</a> is a functional programming language that compiles down to Javascript. In this post, I describe the process of building a simple game, Snake, in PureScript. Along the way, we’ll see how input/signals work, how to render to the screen, and how to work with arrays. I assume familiarity with functional programming. I’ll make some comparisons with Haskell and Elm.</p>
<p>I like Purescript because it has the functional power of <a href="https://www.haskell.org/">Haskell</a>, while fitting very well into the web ecosystem (e.g. interops with Javascript), like <a href="http://www.elm-lang.org">Elm</a>. Think of it as Elm with all the features that come with Haskell, such as monads. <!--foreign functions--></p>
<p>Some resources:</p>
<ul>
<li>Reference
<ul>
<li><a href="http://www.purescript.org">Main page</a></li>
<li><a href="https://leanpub.com/purescript/read">Ebook (PureScript by Example)</a></li>
<li><a href="https://github.com/purescript/purescript/wiki/Language-Guide">Language guide</a></li>
<li><a href="https://pursuit.purescript.org/">Documentation (Pursuit)</a></li>
</ul></li>
<li>Purescript for Haskell/Elm users
<ul>
<li><a href="https://github.com/purescript/purescript/wiki/Differences-from-Haskell">Differences from Haskell</a></li>
<li><a href="http://www.arow.info/blog/posts/2015-12-17-purescript-intro.html">PureScript for the Haskeller</a></li>
<li><a href="http://www.parsonsmatt.org/2015/10/03/elm_vs_purescript.html">Elm vs. PureScript</a></li>
<li><a href="http://www.lambdacat.com/getting-to-know-purescript-from-elm/">Getting to know PureScript from Elm</a></li>
</ul></li>
<li><a href="http://www.purescript.org/community/">Community</a>: The folks on Slack and IRC have been very helpful in helping me get set up and debugging my code.</li>
<li>Other things written using <code>purescript-signal</code>
<ul>
<li><a href="https://github.com/michaelficarra/purescript-demo-mario">Mario</a></li>
<li><a href="https://github.com/bodil/purescript-is-magic">Purescript is Magic</a></li>
</ul></li>
</ul>
<h2 id="getting-started">Getting started</h2>
<p>First follow the instructions <a href="http://www.purescript.org/learn/getting-started/">here</a> to install Purescript.</p>
<p>Start a new project by</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">mkdir</span> basic-games
<span class="kw">cd</span> basic-games
<span class="kw">pulp</span> init</code></pre></div>
<p>Create a file <code>Snake.purs</code> in <code>src/</code>.</p>
<h2 id="imports">Imports</h2>
<p>First, the imports.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Snake</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Prelude</span> <span class="co">-- must be explicitly imported</span>
<span class="kw">import </span><span class="dt">Control.Monad.Eff</span> (<span class="dt">Eff</span>)
<span class="kw">import </span><span class="dt">Control.Monad.Eff.Console</span> (<span class="dt">CONSOLE</span>, log)
<span class="kw">import </span><span class="dt">Control.Monad.Eff.Random</span> (<span class="dt">RANDOM</span>, randomInt)
<span class="kw">import </span><span class="dt">Data.Array</span> (length, uncons, slice, (:), last)
<span class="kw">import </span><span class="dt">Data.Array.Partial</span> (head)
<span class="kw">import </span><span class="dt">Data.Functor</span>
<span class="kw">import </span><span class="dt">Data.Generic</span>
<span class="kw">import </span><span class="dt">Data.Int</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span>
<span class="kw">import </span><span class="dt">Data.Traversable</span>
<span class="kw">import </span><span class="dt">Data.Tuple</span>
<span class="kw">import </span><span class="dt">Graphics.Canvas</span> (<span class="dt">CANVAS</span>, closePath, lineTo, moveTo, fillPath,
                        setFillStyle, arc, rect, getContext2D,
                        getCanvasElementById, <span class="dt">Context2D</span>, <span class="dt">Rectangle</span>, clearRect)
<span class="kw">import </span><span class="dt">Partial.Unsafe</span> (unsafePartial)
<span class="kw">import </span><span class="dt">Signal</span> (<span class="dt">Signal</span>, runSignal, foldp, sampleOn, map4)
<span class="kw">import </span><span class="dt">Signal.DOM</span> (keyPressed)
<span class="kw">import </span><span class="dt">Signal.Time</span> (<span class="dt">Time</span>, second, every)
<span class="kw">import </span><span class="dt">Test.QuickCheck.Gen</span> <span class="co">-- for randomness</span></code></pre></div>
<p>You will need to install all these packages. You can install them one at a time via</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">bower</span> install <span class="kw">&lt;</span>package-name<span class="kw">&gt;</span> --save</code></pre></div>
<p>or copy the <code>bower.json</code> file <a href="https://github.com/holdenlee/purescript-games/blob/master/bower.json">here</a> and do <code>bower install</code> to install all of them at once.</p>
<h2 id="the-model-update-view-signal-architecture">The Model-Update-View-Signal Architecture</h2>
<p>We break our program into the following parts. (For more information, see the <a href="http://guide.elm-lang.org/architecture/">Elm architecture tutorial</a>.)</p>
<ul>
<li><strong>Model</strong>: This is a complete description of the state of the program at any time. For Snake, this would include the array containing all points of the snake, the direction it is going, and the location of the mouse.</li>
<li><strong>Update</strong>: Define a <code>step</code> function which given an input and the current model, returns the updated model. For Snake, an update would be the direction, and the step function would move the snake one unit in that direction, and check for things like whether the snake ate the mouse or bumped into the wall.</li>
<li><strong>View</strong>: Given a model, describe how to render it on the screen.</li>
<li><strong>Signal</strong>: Specify the input signals. A signal of type <code>a</code> is a time-varying value of type <code>a</code>. For a primer on signals see <a href="http://elm-lang.org:1234/guide/reactivity#signals">here</a>.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></li>
</ul>
<p><img src="../../../images/mvus.png"></p>
<p>To put these components together we use:</p>
<ul>
<li><p><code>foldp</code>, the magic function that “folds” the input signals into the model via the <code>step</code> function. Note the similarity to <a href="http://colah.github.io/posts/2015-02-DataList-Illustrated/">foldl</a> both in the type signature and the picture. In the picture <code>a</code> corresponds to <code>Input</code> and <code>b</code> corresponds to <code>Model</code>. So given time-varying inputs and a starting model, <code>foldp</code> produces a time-varying model.</p>
<pre><code>foldp :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; (Signal a) -&gt; (Signal b)</code></pre></li>
<li><p><code>runSignal</code>: Given a signal encapsulating an effect, makes the effect happen.</p>
<pre><code>runSignal :: forall e. Signal (Eff e Unit) -&gt; Eff e Unit</code></pre>
<p>(In the old version of Elm, <code>main</code> is simply a <code>Signal</code>, but here, the type of <code>main</code> is an analogue of <code>IO</code> in Haskell.)</p></li>
</ul>
<!-- which given a signal of type `a` and a way to turn something of type `a` into an effect (e.g. a way to render it), makes the effect happen (e.g. renders it). -->
<p>The skeleton of the program looks like this.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Model</span>
<span class="kw">type</span> <span class="dt">Model</span> <span class="fu">=</span> <span class="fu">???</span>

<span class="ot">start ::</span> <span class="dt">Model</span> 
start <span class="fu">=</span> <span class="fu">???</span>

<span class="co">-- Update</span>
<span class="kw">type</span> <span class="dt">Input</span> <span class="fu">=</span> <span class="fu">???</span>

<span class="ot">step ::</span> <span class="dt">Input</span> <span class="ot">-&gt;</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Model</span>
step inp m <span class="fu">=</span> <span class="fu">???</span>

<span class="co">-- View</span>
<span class="ot">render ::</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> _ <span class="dt">Unit</span> 
render m <span class="fu">=</span> <span class="fu">???</span>

<span class="co">-- Signal </span>
<span class="ot">input ::</span> <span class="dt">Eff</span> _ (<span class="dt">Signal</span> <span class="dt">Input</span>)
input <span class="fu">=</span> <span class="fu">???</span>

<span class="co">-- Putting it all together</span>
<span class="ot">main ::</span> <span class="dt">Eff</span> _ <span class="dt">Unit</span>
main <span class="fu">=</span> 
    void <span class="kw">do</span>
      signal <span class="ot">&lt;-</span> input
	  <span class="co">-- game :: Signal Model</span>
      game <span class="ot">&lt;-</span> foldp step start signal
	  <span class="co">-- map :: forall a b. (a -&gt; b) -&gt; f a -&gt; f b</span>
	  <span class="co">--        (Model -&gt; Eff _ Unit) -&gt; Signal Model -&gt; Signal (Eff _ Unit)</span>
      runSignal (map render game)</code></pre></div>
<p>The <code>Eff</code> monad corresponds to Haskell’s <code>IO</code> monad, but uses <em>extensible effects</em>: it lists out explicitly all the effects it has (access to randomness, DOM, drawing canvas, console, etc.). For example, <code>Eff (random :: RANDOM, canvas :: CANVAS | eff) Unit</code> means having effects that include <code>RANDOM</code> and <code>CANVAS</code>). PureScript will infer all effects if you put <code>_</code>. See <a href="https://leanpub.com/purescript/read#leanpub-auto-the-eff-monad-1">Chapter 8.10</a> of the PureScript book.</p>
<p>For a warm-up, <a href="https://github.com/holdenlee/purescript-games/blob/master/src/SimpleMove.purs">here</a> is a basic example following this paradigm. Here, the model is an integer (the location on a single axis), the update is moving -1, 0, or 1 units, the view is simply writing the location to the console, and the signal comes from the arrow keys once every second.</p>
<h2 id="model">Model</h2>
<p>For Snake, the model is a record containing</p>
<ul>
<li>the location of the <code>mouse</code></li>
<li><code>snake</code> as an array of points</li>
<li>whether the snake is <code>alive</code></li>
</ul>
<p>We also include some the dimensions <code>xd</code>, <code>yd</code> of the game board, the <code>size</code> of each square (alternatively, these can be hard-coded in), and the <code>prev</code> square (this is optional—it gives us an easy way to erase the tail of the snake when it moves). Valid positions are in <span class="math inline">\([1,xd]\times [1,yd]\)</span>.</p>
<p>We want the mouse location to be generated at random. How to do this? We’ll fill in that part later. (For now, you can put in an arbitrary point.)</p>
<p>Note also that the y-coordinate is 0 at the top of the screen and increases going down. The snake starts at the upper-left corner moving right.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Point</span> <span class="fu">=</span> <span class="dt">Tuple</span> <span class="dt">Int</span> <span class="dt">Int</span>

<span class="co">--MODEL</span>
<span class="kw">type</span> <span class="dt">Snake</span> <span class="fu">=</span> <span class="dt">Array</span> <span class="dt">Point</span>

<span class="kw">type</span> <span class="dt">Model</span> <span class="fu">=</span> {<span class="ot">xd ::</span> <span class="dt">Int</span>,<span class="ot"> yd ::</span> <span class="dt">Int</span>,<span class="ot"> size ::</span> <span class="dt">Int</span>,<span class="ot"> mouse::</span> <span class="dt">Point</span>,<span class="ot"> snake ::</span> <span class="dt">Snake</span>,<span class="ot"> dir ::</span> <span class="dt">Point</span>,<span class="ot"> alive ::</span> <span class="dt">Boolean</span>,<span class="ot"> prev ::</span> <span class="dt">Maybe</span> <span class="dt">Point</span>}

<span class="ot">start ::</span> <span class="dt">Model</span>
start <span class="fu">=</span> 
  {xd <span class="fu">:</span> <span class="dv">25</span>, yd <span class="fu">:</span> <span class="dv">25</span>, size <span class="fu">:</span> <span class="dv">10</span>, mouse <span class="fu">:</span> <span class="fu">??</span>, snake <span class="fu">:</span> [<span class="dt">Tuple</span> <span class="dv">1</span> <span class="dv">1</span>], dir<span class="fu">:</span> <span class="dt">Tuple</span> <span class="dv">1</span> <span class="dv">0</span>, alive <span class="fu">:</span> true, prev <span class="fu">:</span> <span class="dt">Nothing</span>}</code></pre></div>
<p>Note unlike Haskell,</p>
<ul>
<li>there is no syntactic sugar for <code>Tuple</code>.</li>
<li>the basic list type is <code>Array</code>.</li>
<li>booleans are <code>Boolean</code> and have values <code>true</code> or <code>false</code>.</li>
</ul>
<h2 id="update">Update</h2>
<p>First we need two helper function: check to see if a point is in bounds, and check to see if the snake is OK (given the point where the head of the snake moves, check to see that it is in bounds and not part of the snake’s body).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">inBounds ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Boolean</span>
inBounds (<span class="dt">Tuple</span> x y) m <span class="fu">=</span> 
  (x <span class="fu">&gt;</span> <span class="dv">0</span>) <span class="fu">&amp;&amp;</span> (y <span class="fu">&gt;</span> <span class="dv">0</span>) <span class="fu">&amp;&amp;</span> (x <span class="fu">&lt;=</span> m<span class="fu">.</span>xd) <span class="fu">&amp;&amp;</span> (y <span class="fu">&lt;=</span> m<span class="fu">.</span>yd)

<span class="ot">checkOK ::</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Boolean</span>
checkOK pt m <span class="fu">=</span> 
  <span class="kw">let</span>
    s <span class="fu">=</span> m<span class="fu">.</span>snake
  <span class="kw">in</span>
    m<span class="fu">.</span>alive <span class="fu">&amp;&amp;</span> (inBounds pt m) <span class="fu">&amp;&amp;</span> not (pt <span class="ot">`elem`</span> (body s))
	
<span class="ot">body ::</span> forall a<span class="fu">.</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> <span class="dt">Array</span> a
body li <span class="fu">=</span> slice <span class="dv">0</span> ((length li) <span class="fu">-</span> <span class="dv">1</span>) li</code></pre></div>
<p>For the step function, there are 3 cases:</p>
<ul>
<li>The snake is OK:
<ul>
<li>The snake eats the mouse. The snake grows, and regenerate the mouse on a random square. (We omit the randomness for now.)</li>
<li>The snake doesn’t eat the mouse, in which case it moves. Here <code>body</code> is all of the snake except the last point.</li>
</ul></li>
<li>The snake is not OK: <code>alive = false</code> and nothing else happens.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">step ::</span> <span class="dt">Partial</span> <span class="ot">=&gt;</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Model</span>
step dir m <span class="fu">=</span> 
  <span class="kw">let</span>
	<span class="co">-- override the direction with the input, unless there is no input (corresponding to (0,0))</span>
    d <span class="fu">=</span> <span class="kw">if</span> dir <span class="fu">/=</span> <span class="dt">Tuple</span> <span class="dv">0</span> <span class="dv">0</span>
        <span class="kw">then</span> dir
        <span class="kw">else</span> m<span class="fu">.</span>dir
    s <span class="fu">=</span> m<span class="fu">.</span>snake
    <span class="kw">let</span> hd <span class="fu">=</span> (head s <span class="fu">+</span> d)
    <span class="kw">if</span> checkOK hd m
      <span class="kw">then</span> 
        <span class="kw">if</span> (hd <span class="fu">==</span> m<span class="fu">.</span>mouse) 
        <span class="kw">then</span> m { snake <span class="fu">=</span> hd <span class="fu">:</span> s
               , mouse <span class="fu">=</span> <span class="fu">???</span>
               , dir <span class="fu">=</span> d
               , prev <span class="fu">=</span> <span class="dt">Nothing</span> <span class="co">-- snake grows; nothing is deleted</span>
               }
        <span class="kw">else</span> m { snake <span class="fu">=</span> hd <span class="fu">:</span> (body s)
               , dir <span class="fu">=</span> d
               , prev <span class="fu">=</span> last s <span class="co">-- snake moves; the last pixel is deleted</span>
               }
      <span class="kw">else</span> m { alive <span class="fu">=</span> false, prev <span class="fu">=</span> <span class="dt">Nothing</span>}</code></pre></div>
<p>Some differences from Haskell:</p>
<ul>
<li>Note that all partial functions must be notated with the empty type constraint <code>Partial</code>. <code>head</code> as imported from <code>Data.Array.Partial</code> is a partial function because it is undefined on <code>[]</code>. (We need not worry because the snake will never be empty.)</li>
<li>Polymorphic functions must have type variables listed out at the beginning after <code>forall</code>.</li>
</ul>
<p>Note that we can add points! (Note the line <code>head s + d</code>.) This is because <code>Data.Tuple</code> has the instance <code>(Ring a, Ring b) =&gt; Ring (Tuple a b)</code>. If both components of a tuple can be added, then addition is automatically defined for the tuple.</p>
<h2 id="view">View</h2>
<p>Given the model, we have 4 things to render: the walls (a <span class="math inline">\(27\times 27\)</span> rectangle here), the background (a <span class="math inline">\(25\times 25\)</span> rectangle), the snake and the mouse. For instructions on using <code>purescript-canvas</code> see <a href="https://leanpub.com/purescript/read#leanpub-auto-canvas-graphics">Chapter 9</a> of the PureScript book. Change the colors as you wish.</p>
<pre><code>render :: forall eff. Partial =&gt; Model -&gt; (Eff _ Unit)
render m = 
  void do
        let s = m.snake
        let size = m.size
        Just canvas &lt;- getCanvasElementById &quot;canvas&quot;
        ctx &lt;- getContext2D canvas
        --walls
        setFillStyle wallColor ctx
        fillPath ctx $ rect ctx
                     { x: 0.0
                     , y: 0.0
                     , w: toNumber $ size*(m.xd + 2)
                     , h: toNumber $ size*(m.yd + 2)
                     }
        --interior
        setFillStyle bgColor ctx
        fillPath ctx $ rect ctx
                     { x: toNumber $ size
                     , y: toNumber $ size
                     , w: toNumber $ size*(m.xd)
                     , h: toNumber $ size*(m.yd)
                     }
        --snake 
        for s (\x -&gt; colorSquare m.size x snakeColor ctx)
        --mouse
        colorSquare m.size (m.mouse) mouseColor ctx
		
colorSquare :: forall eff. Int -&gt; Point -&gt; String -&gt; Context2D -&gt; Eff (canvas :: CANVAS | eff) Context2D
colorSquare size (Tuple x y) color ctx = do
  setFillStyle color ctx
  fillPath ctx $ rect ctx $ square size x y

square :: Int -&gt; Int -&gt; Int -&gt; Rectangle
square size x y = { x: toNumber $ size*x
                  , y: toNumber $ size*y
                  , w: toNumber $ size
                  , h: toNumber $ size
                  }

white = &quot;#FFFFFF&quot;
black = &quot;#000000&quot;
red = &quot;#FF0000&quot;
yellow = &quot;#FFFF00&quot;
green = &quot;#008000&quot;
blue = &quot;#0000FF&quot;
purple = &quot;800080&quot;

snakeColor = white
bgColor = black
mouseColor = red
wallColor = green</code></pre>
<p>The render function is a bit inefficient since it is redrawing the entire canvas every step (it doesn’t make much difference for such a simple game though). We can replace later calls to <code>render</code> with <code>renderStep</code> which only changes the squares that need to be changed at each time step. (There is much more freedom than Elm to draw specify what you want to draw and redraw.)</p>
<pre><code>renderStep :: forall eff. Partial =&gt; Model -&gt; Eff (canvas :: CANVAS | eff) Unit
renderStep m = 
  void do
        let s=m.snake
        Just canvas &lt;- getCanvasElementById &quot;canvas&quot;
        ctx &lt;- getContext2D canvas
        colorSquare m.size (head s) snakeColor ctx
        case m.prev of
          Nothing -&gt; colorSquare m.size (m.mouse) mouseColor ctx
          Just pt -&gt; colorSquare m.size pt bgColor ctx
		  --make use of the fact: either we draw the mouse or erase the tail, not both, at any one step
</code></pre>
<h2 id="signal">Signal</h2>
<p>The <code>step</code> function takes an update of type <code>Point</code>, so we need to produce a <code>Signal Point</code>.</p>
<p><a href="https://pursuit.purescript.org/packages/purescript-signal/8.0.0">purescript-signal</a> contains signals from various sources, e.g. which keys are pressed and the time. We use the following functions from there:</p>
<ul>
<li><code>keyPressed :: forall e. Int -&gt; Eff (dom :: DOM | e) (Signal Boolean)</code>. (Note we need access to the DOM to get a keybord signal.) The key codes for L/U/D/R are 37, 38, 40, 39. We map them to <span class="math inline">\((-1,0), (0,-1), (0,1), (1,0)\)</span>, respectively.</li>
<li><code>every :: Time -&gt; Signal Time</code> periodically signals the time.</li>
<li><code>sampleOn :: forall a b. (Signal a) -&gt; (Signal b) -&gt; (Signal b)</code> creates a signal which yields the current value of the second signal every time the first signal yields. Usually the first signal is a periodic time signal (e.g. <code>every second</code>).</li>
</ul>
<p>Below, <code>input</code> gives a direction corresponding to the arrow key pressed every 1/20 second.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">--SIGNALS</span>
<span class="ot">inputDir ::</span> <span class="dt">Eff</span> _ (<span class="dt">Signal</span> <span class="dt">Point</span>)
inputDir <span class="fu">=</span> 
    <span class="kw">let</span> 
        f <span class="fu">=</span> \l u d r <span class="ot">-&gt;</span> ifs [<span class="dt">Tuple</span> l <span class="fu">$</span> <span class="dt">Tuple</span> (<span class="fu">-</span><span class="dv">1</span>) <span class="dv">0</span>, <span class="dt">Tuple</span> u <span class="fu">$</span> <span class="dt">Tuple</span> <span class="dv">0</span> (<span class="fu">-</span><span class="dv">1</span>), <span class="dt">Tuple</span> d <span class="fu">$</span> <span class="dt">Tuple</span> <span class="dv">0</span> <span class="dv">1</span>, <span class="dt">Tuple</span> r <span class="fu">$</span> <span class="dt">Tuple</span> <span class="dv">1</span> <span class="dv">0</span>] <span class="fu">$</span> <span class="dt">Tuple</span> <span class="dv">0</span> <span class="dv">0</span>
<span class="co">--note y goes DOWN</span>
    <span class="kw">in</span>
      map4 f <span class="fu">&lt;$&gt;</span> (keyPressed <span class="dv">37</span>) <span class="fu">&lt;*&gt;</span> (keyPressed <span class="dv">38</span>) <span class="fu">&lt;*&gt;</span> (keyPressed <span class="dv">40</span>) <span class="fu">&lt;*&gt;</span> (keyPressed <span class="dv">39</span>)

<span class="ot">input ::</span> <span class="dt">Eff</span> _ (<span class="dt">Signal</span> <span class="dt">Point</span>)
input <span class="fu">=</span> sampleOn (fps <span class="fl">20.0</span>) <span class="fu">&lt;$&gt;</span> inputDir

<span class="ot">fps ::</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> <span class="dt">Signal</span> <span class="dt">Time</span>
fps x <span class="fu">=</span> every (second<span class="fu">/</span>x)

<span class="ot">ifs::</span> forall a<span class="fu">.</span> <span class="dt">Array</span> (<span class="dt">Tuple</span> <span class="dt">Boolean</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
ifs li z <span class="fu">=</span> <span class="kw">case</span> uncons li <span class="kw">of</span>
             <span class="dt">Just</span> {head <span class="fu">:</span> <span class="dt">Tuple</span> b y, tail <span class="fu">:</span> tl} <span class="ot">-&gt;</span> <span class="kw">if</span> b <span class="kw">then</span> y <span class="kw">else</span> ifs tl z
             <span class="dt">Nothing</span>         <span class="ot">-&gt;</span> z </code></pre></div>
<p>At this point, we can slap in a <code>main</code> and then compile.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">Eff</span> _ <span class="dt">Unit</span>
main <span class="fu">=</span>
    void <span class="fu">$</span> unsafePartial <span class="kw">do</span>
      <span class="co">-- create the signal</span>
      dirSignal <span class="ot">&lt;-</span> input
      game <span class="ot">&lt;-</span> foldp step start dirSignal
      runSignal (map render game)</code></pre></div>
<p>But we don’t have randomness yet.</p>
<h2 id="adding-randomness">Adding randomness</h2>
<p>How do we model randomness in a purely functional program?</p>
<p>We need to add randomness as an effect.</p>
<h3 id="something-that-doesnt-work">Something that doesn’t work</h3>
<p>The initialization and step functions need randomness, so we can try to rewrite the functions so they have the following type signatures:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">init<span class="ot"> ::</span> <span class="dt">Eff</span> (<span class="ot">random::</span> <span class="dt">RANDOM</span>) <span class="dt">Model</span> 

<span class="ot">step ::</span> forall e<span class="fu">.</span> <span class="dt">Point</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">random::</span><span class="dt">RANDOM</span> <span class="fu">|</span> e) <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">random::</span><span class="dt">RANDOM</span> <span class="fu">|</span> e) <span class="dt">Model</span>

<span class="ot">render ::</span> <span class="dt">Eff</span> (<span class="ot">random::</span> <span class="dt">RANDOM</span>) <span class="dt">Model</span> <span class="ot">-&gt;</span> <span class="dt">Eff</span> _ <span class="dt">Unit</span> 

<span class="ot">input ::</span> <span class="dt">Eff</span> _ (<span class="dt">Signal</span> <span class="dt">Update</span>)

<span class="co">-- Putting it all together</span>
<span class="ot">main ::</span> <span class="dt">Eff</span> _ <span class="dt">Unit</span>
main <span class="fu">=</span> 
    void <span class="kw">do</span>
      startGame <span class="ot">&lt;-</span> init
      signal <span class="ot">&lt;-</span> input
	  <span class="co">-- game :: Signal Model</span>
      game <span class="ot">&lt;-</span> foldp step startGame signal
	  <span class="co">-- map :: (a -&gt; b) -&gt; f a -&gt; f b</span>
	  <span class="co">--        (Model -&gt; Eff _ Unit) -&gt; Signal Model -&gt; Signal (Eff _ Unit)</span>
      runSignal (map render game)</code></pre></div>
<p>If you try this you will get very weird behavior: the mouse will jump all over the place! My best explanation for this is that the effects are compiled in un-executed form in the signal, and at each step, the effects are executed <em>starting from the beginning</em>. Not only does this mean that the random numbers generated are different, it means that the the program will run slower and slower. See a discussion <a href="https://groups.google.com/forum/#!msg/purescript/CeVEETR0U3U/oacKYPmXAwAJ">here</a>.</p>
<h3 id="using-a-generator">Using a generator</h3>
<p>The standard way to do this is to include a <code>Seed</code> in the state, and whenever we need randomness, use the seed to generate a random number and a new seed, and update the seed. We can add a field for <code>seed</code> in <code>Model</code>…</p>
<p>But this is clunky, and just the kind of thing that monads make easier to express! This sounds like a <code>State Seed</code> and in fact, the <a href="https://pursuit.purescript.org/packages/purescript-quickcheck/3.0.0/docs/Test.QuickCheck.Gen">Gen</a> monad is (basically) just this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">GenState</span> <span class="fu">=</span> {<span class="ot"> newSeed ::</span> <span class="dt">Seed</span>,<span class="ot"> size ::</span> <span class="dt">Size</span> }

<span class="kw">newtype</span> <span class="dt">Gen</span> a <span class="fu">=</span> <span class="dt">Gen</span> (<span class="dt">StateT</span> <span class="dt">GenState</span> <span class="dt">Identity</span> a)</code></pre></div>
<p>Our step function will no longer be <code>a -&gt; b -&gt; b</code>, but will draw on randomness, so will take the form <code>a -&gt; b -&gt; Gen b</code>. We now replace</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldp ::</span> forall a b<span class="fu">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> (<span class="dt">Signal</span> a) <span class="ot">-&gt;</span> (<span class="dt">Signal</span> b)</code></pre></div>
<p>with the function</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">foldpR ::</span> forall a b e<span class="fu">.</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Gen</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> (<span class="dt">Signal</span> a) <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="ot">random ::</span> <span class="dt">RANDOM</span> <span class="fu">|</span> e) (<span class="dt">Signal</span> b)</code></pre></div>
<p>This is very reusable, and will make anything else we write with randomness painless.</p>
<p>For this, we need a bit of footwork. Behind the scenes, we do as we said before: a function <code>f :: a -&gt; b -&gt; Gen b</code> is the same as a function <code>f' :: a -&gt; (b, GenState) -&gt; (b, GenState)</code>. We unravel <code>f</code>, and <code>foldp</code> using this <code>f'</code> as the step function and an initial seed. For sake of reusability, I’ve put <code>foldpR</code> in a separate module, in more generality than necessary, <a href="https://github.com/holdenlee/purescript-games/blob/master/src/SignalM.purs">here</a>; add <code>import SignalM</code> to <code>Snake</code>.</p>
<p>The function <code>step :: Partial =&gt; Point -&gt; Model -&gt; Model</code> is now <code>step :: Partial =&gt; Point -&gt; Model -&gt; Gen Model</code>. In the branch of the <code>if</code> statement where the snake eats the mouse, we keep generating points within the dimensions until the point is not part of the snake. Note that PureScript uses <code>pure</code> instead of <code>return</code>. We add <code>pure</code> to the other branches (not shown).</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">do</span> 
    newMouse <span class="ot">&lt;-</span> untilM (\pt <span class="ot">-&gt;</span> not (pt <span class="ot">`elem`</span> s <span class="fu">||</span> pt <span class="fu">==</span> hd)) (randomPoint m<span class="fu">.</span>xd m<span class="fu">.</span>yd)
    pure <span class="fu">$</span> m { snake <span class="fu">=</span> hd <span class="fu">:</span> s
             , mouse <span class="fu">=</span> newMouse
             , dir <span class="fu">=</span> d
             , prev <span class="fu">=</span> <span class="dt">Nothing</span> <span class="co">-- snake grows; nothing is deleted</span>
             }</code></pre></div>
<p>The auxiliary functions here are (<code>untilM</code> being the monadic analogue of “repeat until”)</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">untilM ::</span> forall m a<span class="fu">.</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Boolean</span>) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a
untilM cond ma <span class="fu">=</span> 
    <span class="kw">do</span> 
      x <span class="ot">&lt;-</span> ma
      <span class="kw">if</span> cond x <span class="kw">then</span> pure x <span class="kw">else</span> untilM cond ma

<span class="ot">randomPoint ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">Point</span>
randomPoint xmax ymax <span class="fu">=</span> 
    <span class="kw">do</span>
      x <span class="ot">&lt;-</span> chooseInt <span class="dv">1</span> xmax
      y <span class="ot">&lt;-</span> chooseInt <span class="dv">1</span> ymax
      pure <span class="fu">$</span> <span class="dt">Tuple</span> x y</code></pre></div>
<p>We also similarly incorporate randomness in the starting model by replacing <code>start :: Model</code> with <code>init :: forall e. Eff (random::RANDOM | e) Model</code>. The final <code>main</code> looks like</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">Eff</span> _ <span class="dt">Unit</span>
main <span class="fu">=</span> 
    void <span class="fu">$</span> unsafePartial <span class="kw">do</span>
      <span class="co">--draw the board</span>
      gameStart <span class="ot">&lt;-</span> init
      render gameStart
      <span class="co">-- create the signals</span>
      dirSignal <span class="ot">&lt;-</span> input
      <span class="co">-- need to be in effect monad in order to get a keyboard signal</span>
      game <span class="ot">&lt;-</span> foldpR step gameStart dirSignal
      runSignal (map renderStep game)</code></pre></div>
<p>See all the code <a href="https://github.com/holdenlee/purescript-games/blob/master/src/Snake.purs">here</a>.</p>
<p>The version I linked to has a few extra lines of code so that pressing SPACE restarts the game; the additions are in <a href="https://github.com/holdenlee/purescript-games/blob/master/src/SnakeS.purs">SnakeS.purs</a>, at the bottom.</p>
<h2 id="building">Building</h2>
<p>To build the project, run</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">mkdir</span> dist
<span class="kw">pulp</span> build
<span class="kw">pulp</span> browserify -m Snake/index.js <span class="kw">&gt;&gt;</span> dist/Snake.js</code></pre></div>
<p>Browserify creates a javascript file with all the javascript libraries included. We need a html file to host the javascript. Create <code>html/index.html</code> with a canvas of the appropriate dimensions:</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="dt">&lt;!DOCTYPE </span>html<span class="dt">&gt;</span>
<span class="kw">&lt;html&gt;</span>
  <span class="kw">&lt;head&gt;</span>
    <span class="kw">&lt;title&gt;</span>Snake<span class="kw">&lt;/title&gt;</span>
  <span class="kw">&lt;/head&gt;</span>
  <span class="kw">&lt;body&gt;</span>
    <span class="kw">&lt;canvas</span><span class="ot"> id=</span><span class="st">&quot;canvas&quot;</span><span class="ot"> width=</span><span class="st">&quot;270&quot;</span><span class="ot"> height=</span><span class="st">&quot;270&quot;</span><span class="ot"> style=</span><span class="st">&quot;border: 1px solid black; display: block; margin: auto;&quot;</span><span class="kw">&gt;&lt;/canvas&gt;</span>
    <span class="kw">&lt;script</span><span class="ot"> type=</span><span class="st">&quot;text/javascript&quot;</span><span class="ot"> src=</span><span class="st">&quot;../dist/Snake.js&quot;</span><span class="kw">&gt;&lt;/script&gt;</span>
  <span class="kw">&lt;/body&gt;</span>
<span class="kw">&lt;/html&gt;</span></code></pre></div>
<p>Now open the file and play!</p>
<!--
# Exercises

* Add a tab for score.
* Add a start screen. Press SPACE to begin. When the game ends, display "GAME OVER, SPACE to play again".
* Add sounds whenever the snake eats a mouse.
* Change the amount that the snake lengthens each time.
* Allow the user to adjust the speed and the lengthening rate.
-->
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The PureScript signal library is very similar to the former Elm signal library. Note that Elm no longer uses signals.<a href="#fnref1">↩</a></p></li>
</ol>
</section>

  </div>

    

    <!-- Extension : Sharing buttons @ www.sharethis.com -->
    <span class="st_facebook_large" displayText="Facebook"></span>
    <span class="st_twitter_large" displayText="Tweet"></span>
    <span class="st_googleplus_large" displayText="Google +"></span>
    <span class="st_reddit_large" displayText="Reddit"></span>
    <span class="st__large" displayText></span>

    <div id="disqus_thread"></div>
    


  
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
  </div>
  
</div>


<!-- Footer -->
<div id="footer">
  <div class="container">
    Built with
    <a href="http://jaspervdj.be/hakyll">Hakyll</a> 
    using 
    <a href="http://www.getbootstrap.com">Bootstrap</a>, 
    <a href="http://www.disqus.com">Disqus</a>,
    <a href="http://ignorethecode.net/blog/2010/04/20/footnotes/">Footnotes.js</a>,
    <a href="http://highlightjs.org/">Highlight.js</a>, 
    <a href="http://www.mathjax.org">MathJax</a>, 
    and <a href="http://www.sharethis.com">ShareThis</a>.
  </div>
</div>
</body>

</html>

<!-- SCRIPTS -->
<!-- jQuery-->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
<script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>

<script src="../../../bootstrap/js/bootstrap.min.js"></script>

<!-- Extension : Highlight.js @ https://highlightjs.org/ -->
<!-- Syntax highlighting tomorrow-night-bright, agate-->
<link rel="stylesheet" href="../../../highlight/css/tomorrow-night-bright.css">
<script src="../../../highlight/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<!-- Extension : MathJax @ https://docs.mathjax.org/en/v2.5-latest/tex.html -->
<!-- MathJax/config/local/local.js contains macros. Need to provide entire URL-->
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML,http://holdenlee.github.io/blog/MathJax/config/local/local"></script>

<!-- Extension : Footnotes @ http://ignorethecode.net/blog/2010/04/20/footnotes/ -->
<script src="../../../footnotes/js/footnotes.js"></script>

<!-- Extension : Disqus @ http://disqus.com -->
<!-- Extension : InlineDisqussions @ https://github.com/tsi/inlineDisqussions -->

<script src="../../../disqus/js/disqus.js"></script>

<script src="../../../disqus/js/inlineDisqussions.js"></script>
<link rel="stylesheet" type="text/css" href="../../../disqus/css/inlineDisqussions.css" />



<!-- Extension : Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-73261814-1', 'auto');
  ga('send', 'pageview');

</script>

